//"purely functional language" - no mutable state. period.
//Example: Haskell
//
// add: (a: Number) => a -> a -> a
// add x y = x + y
//
//hello world is so complicated in Haskell that you
//would not learn it in a functional programming class
//this is because any form of I/O is a mutable state
//and Haskell is purely functional which means no mutable state
//
//So why Swift?
// -Popular
// -Coherent: designed to do a certain set of things and intentionally designed
//            to only do those certain things
//Why not Scala?
//Type inference is whack 



print("Hello World")



//let x = 1 + 2
//x = 27
//print(x)
//using let means it is a constant
//line 20 is not proper and is a compile time error because x cannot be reassigned
//to be able to reassign you would have to use var



//var x = 1 + 2
//x = "foo"
//print(x)
//this is also an error even though var allows reassigning
//Swift has type inference 
//At compile time: x? = int + int gives back an int, so x is an int


let x = 1 + 2
print(x)
//get the advantage of dynamic typing - don't have to assign the type
//also get the advantage of static typing - type is checked at compile time
//the language is statically typed; the type cannot be changed



func getFirstArgument(x: Int, y: String) -> Int {
    return x
}
//Swift: local type inference
//Assumes some types are provided and it is able to provide the rest
//Specifically assumes when you provide a named function the types of parameters and returns must be provided
//Java syntax:
//public static int getFirstArgument(int x, String y) { return x; }

//getFirstArgument(3, "foo") -> gives an error
getFirstArgument(x: 3, y: "foo") //have to specify the argument labels



//if you don't want to provide names:
func getSecondArgument(_ first: Int, second: String) -> String {
    return second
}

getSecondArgument(4, second: "bar") //now this works
//this is because the _ means the caller doesn't specify the labels


func blah(x: Int) -> Int {return x }
func blah(y: Int) -> Int {return y }
//the diff labels allow overloading


//Self documenting code is the idea that the code itself tells you what the code does
//Usually there is a heavy emphasis on naming things very descriptively and very well so that you
//can figure out what is going on just from the names that are used (not just variables - for everything)
