//Swift does have booleans, if/else. true and false are the only boolean values
//Similarly to python - do not need () around if/else condition
let b: Bool = true

if b {
	print("hi")
} else {
	print("bye")
}

//this means: returns a function that takes an integer and returns an integer
func addAmount(amount: Int) -> (Int) -> Int {
	return ( x in x + amount }
}
//JS comparison:
//	function addAmount(amount) {
//		return x => x + amount
//	}

let addFive: (Int) -> Int = addAmount(amount: 5)
let addThree = addAmount(amount: 3)

print(addFive(2))
print(addThree(3))

//RESULTS: 7, 6

Cost of a higher order function:
Typically only slightly more expensive than a regular function, cheaper than virtual dispatch

What happens?
Ex: 
	func addAmount(amount: Int) -> (Int) -> Int {
	//memory allocated:
	// - space for an integer (amount)
	// - space for a function pointer
	return { x in amount + x }
	}
	
--------------ENUM--------------
Algebraic data type 
	- Functional languages almost always have algebraic data types
	- Not the same as higher order functions 
Idea is:
	type myType = Constructor 1 | Constructor 2
	you have some type you can specify
	the constructors of the type are different ways to produce something of the same type
	
Example: Bool = true | false
	at the type level there is no distinguishing between true & false
	
Create your own:
	type StoplightColors = Red | Green | Yellow
	What allows this?
		Feature called pattern matching:
			- at runtime check which one is used
			- execute specific code accordingly 
			- specific example: booleans - if/else
			

enum StoplightColor {
	case red
	case green
	case yellow 
}

let color: StoplightColor = StoplightColor.red

switch color {
case .red: 
	print("red")
case .green: 
	print("green")
case .yellow: 
	print("yellow")

What is this saying?
	- There is a type StoplightColor
	- There are 3 instances of it
What is switch?
	- Switch is the way to have type matching 
	- It checks the value to see which one it matches and then executes the code 
		HOWEVER!! you do not need break. Switch in Swift does not behave the same as it does in Java.
		It is essentially a big if/else statement. 
		
//indirect = recursive 
indirect enum IntegerList {
	case Nil
	case Cons(Int, IntegerList)
}

let list: IntegerList = IntegerList.Cons(1, IntegerList.Cons(2, IntegerList.Nil))

switch list {
	case .Cons(let head, let tail):
		print(head)
	case .Nil:
		print("EMPTY")
}
//Why let? First thing in list -> bind to head, Second thing in list -> bind to tail
	