---------------------Tuples---------------------

let tuple1: (Int, String, Bool) = (1, "foo", true) //3-tuple
let tuple2: (Int, Int, Int) = (1, 2, 3) //3-tuple
let tuple3: (String, Int) = ("blah", 17) //2-tuple
let tuple4 = (Int, (Int) -> Int) = (18, { x in x+1})
let tuple 5 = ((Int, Int), (Bool, Bool)) = ((1, 2), (true, false))


---------------------Specializing---------------------
C++ style of handling generics - specialize the generic definiton per w/e types you work with

func funcTwo_int_int(_ a: Int, _ b: Int) -> (Int, Int) { return (a,b); }
func funcTwo_int_string(_ a: Int, _ b: String) -> (Int, String) { return (a, b); }

let temp1: (Int, Int) = funcTwo_int_int(1, 2)
let temp2: (Int, String) = funcTwo_int_string(1, "foo")
let temp3: (Int, Int) = funcTwo_int_int(3, 4)


---------------------Boxing---------------------
JAVA style of handling generics - boxing

//<A,B> in the middle of nowhere - introducing the types A, B - Pair<A,B> is the return time
public static <A, B> Pair<A,B> funcTwo(A a, B b) {
	return new Pair(a, b);
}

Pair<Int, Int> temp1 = funcTwo(1, 2);
Int temp1Int = (Int) temp1.firstValue;
